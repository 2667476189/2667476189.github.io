---
title: 202107KMMS认定记录
date: 2021-08-03 17:47:37
tags:
    - 笔试题
---

记录202107KMMS认定
<!--more-->

## 认定内容与要求

| 认定内容     | 认定要求                                                     |
| ------------ | ------------------------------------------------------------ |
| Ajax/json    | 1.了解基本的原理，会用jsonp方式跨域<br />2.会使用ajax编写程序<br />3.知道json的数据结构，会使用Json组织数据 |
| ES6初级      | 1.掌握let和const命令<br/>2.了解变量的解构赋值，掌握常规使用<br/>3.了解字符串的扩展，掌握常规使用<br/>4.了解掌握数值，数组，函数，对象的扩展<br/>5.掌握Promise，Module对象 |
| 前端调试     | 熟练使用各种调试工具，进行css调试，js排错优化。如：firebug，developer tool |
| 编码工具     | Vscode的使用，配置等                                         |
| html初级     | 1.基本语法、标签、声明、属性<br/>2.标签属于什么元素，内联/内联-块级/块级元素 |
| css初级      | 1.熟悉css基本语法，以及css工作原理<br/>2.熟练使用css selector 常规选择器class，id,元素，后代，通用，了解选择器的优先级<br/>3.熟悉浮动，定位，盒模型，背景，字体，颜色等常用属性，能运用css进行页面布局和展现效果图 |
| js初级       | 1.熟悉js基本语法，以及js工作原理<br/>2.了解js的基本数据类型,js操作符，语句，变量<br/>3.能进行基础的DOM操作（增删改查）和BOM操作<br/>4.能通过一些事件进行简单的页面交互，例如，点击，双击，鼠标划过等等 |
| 需求分析初级 | 1.需求整体确定的流程<br />2.5W1H工作法的内容<br />3.偏后端的结构化分析方法和面向对象分析方法 |
| 原型初级     | 能够了解并使用一些Axure中的功能                              |

## Ajax/json

- Ajax原生请求的书写的步骤

- 跨域，怎样算是跨域

  同源的定义是两个URL的protocal,host,port相同，则两个URL属于同源，在考虑port的时候如果没有显式填写port，会按协议默认的port考虑，例如`http:127.0.0.1:80`和`http:127.0.0.1/test`同源，`https:127.0.0.1:81`和`https:127.0.0.1`同源。而host是不会把域名先解析成ip判断的，例如localhost和127.0.0.1不同源。

  

- jsonp是怎么个用法

  利用网页实时插入运行的脚本调用函数来实现跨域的api

  ```js
  function jsonp(url){
      let script = document.createElement('script');
      script.src = url;
      document.body.appendChild(script);
  }
  function handle(data){
      console.log(data);
  }
  // 百度候选词api
  let qustion = 'Chi';
  // jsonp的api的链接都会有一个参数叫cb或者callback的，放在后面时会原封不动作为调用的函数名
  let cb = 'handle';
  jsonp(`https://www.baidu.com/sugrec?pre=1&p=3&ie=utf-8&json=1&prod=pc&from=pc_web&wd=${qustion}&req=2&csor=5&pwd=script&cb=${cb}`);
  ```

- json中，哪些不能从JavaScript Object转换为JavaScript Object Notation

  - 包含循环引用和BigInt会异常
  - 方法、undefined和Symbol分两种情况，直接出现在对象键值对作为值的被忽略，出现在数组中的用null作为占位符

## ES6初级

- 解构赋值是怎样使用的，解构赋值的默认值和ES6的函数默认值混用时的区别

  ```js
  {
      p:['a',{y:'b'}]
  }
  ```

  从以上字面量中取出字符串a和字符串b，并取出p（左边是模式，右边是接收赋值的变量标识符，简写p<=>p:p）

  ```js
  let {p:[paramsA,{y:paramsB}],p}={
      p:['a',{y:'b'}]
  }
  ```

  默认值的区别例子

  ```js
  function f({x=0,y=0}={}){ console.log(x,y) }
  function f2({x,y}={x:0,y:0}){ console.log(x,y) }
  ```

  其区别的产生在于如果收到了任意第一个参数，那么右侧的函数默认值立刻会被弃用，而左侧的解构赋值的默认值仅在解构成功时会被弃用，例如传入参数为一个数字1，那么f中仍然有x=0,y=0;f2中x和y均为undefined

- 字符串的拓展有哪些

  1. 最常用的字符串模板
  2. 字符串也可以使用for-of迭代
  3. 不常用的对于unicode字符的支持

- 数值的拓展有哪些

  1. 新的判断方法isFinite、isNaN
  2. 对于进制的支持

- 函数的拓展有哪些

  1. 函数的默认值的使用方式
  2. 使用...进行剩余参数收集，Rest参数必须是最后一个参数，否则定义时会报语法错误，如果没收集到参数，一般的值会是undefined，而Rest参数会是空数组
  3. 函数的length属性，该属性指明了无默认值的函数参数的个数

- 对象的拓展有哪些

  方法和属性都可以使用简写方式

  ```js
  let a = 1
  let exam = {
      a,// 与外部同名的成员不必再写成a:a
      foo(){// 函数不必再写成 foo:function(){}
          console.log(123)
      }
  }
  ```

  变量做key

  ```js
  let s1 = 'm'
  let s2 = 'n'
  let obj = {
      [s1+s2] : 1234
  }
  // obj.mn
  ```

  对象的descriptor（比较复杂，主要是对象各成员属性的一些元属性）

- 数组的拓展有哪些

  拓展运算符，类数组转为数组的方法`Array.from`,比较常用的`Array.includes`以及`keys()`、`entries()`和`values()`三个遍历方法

- 如何使用fill填充一个数组，使其成为一个有100个1的数组
  这个方法是数组实例的一个方法，将数组实例现有的所有元素包括空位全部填充为其第一个参数，第二和第三个参数为起始和结束的前一个,param2 <= index < param3的值全部会被填充。因此上面的题目的答案应该为

  ```js
  let arr = new Array(100).fill(1)
  ```

  

- ES6 Module怎么引入模块（一般的导出接口和导出默认接口）

  ```js
  // 导出
  let a = 1,b = 2
  export {a,b} // 必须按接口导出
  export default a // default可以不需要，因为default自己就是一个接口
  export {a as otherA,b as otherB}// 重命名
  ```

  ```js
  // 导入
  import {a,b} from './m'
  import {otherA as aaa,otherB as bbb} from './m'
  import f from './m'
  import {default as f} from './m'
  ```

- ES6 Module是否有缓存

  有缓存，在原模块中的修改会在引入的模块中实时表现

- 能否动态引入
  为了进行静态分析，提高效率，所以无法动态导入导出

  可以使用import()进行动态的导入导出

- Promise有哪些静态方法

  `Promise.all`全部fulfilled后才会把返回的的Promise实例变为fulfilled，把产物变为数组传给onfulfilled；如果有一个reject了，返回的实例就rejected,只把对应的reject的那个数据给到.catch

  `Promise.allSettled`传入的promise都尘埃落定后，返回所有的promise的状态和值如{status:'fulfilled',value:123}

  `Promise.any`和`Promise.all`相反，成功一个就立刻返回，只返回成功的那个值

  `Promise.race`和`Promise.any`意思相近，不过是尘埃落定一个就立刻返回，只返回尘埃落定的那个状态的值

- Promise的链条

  ```js
  let p = new Promise((resolve,reject)=>{
      reject(123)
  })
  p.then(value=>{
      return value
  },e=>{
      return e
  }).then(value=>{
      console.log('success',value)
  },e=>{
      console.log('fail',e)
  })
  ```

  上面这个打印的是success 123还是fail 123
  
  是success 123，后续的.then链的return会将其包装为onfulfilled的状态的Promise

## 前端调试

- dev tool如何为页面中的元素增加悬浮等状态

  在右边的CSS的工具中的:hov中添加元素状态即可

- 使用js调试器打条件式断点，查看堆栈，watch
  在源中使用ctrl+p搜索源文件，右击某一行打条件式断点，右侧可以查看暂停时的调用堆栈、添加监视表达式

- 性能调试工具的使用方法

  1. 使用隐私模式打开页面避免插件的干扰
  2. 性能面板上使用Network和CPU模拟坏网络环境和移动设备算力不足时的性能表现
  3. 查看FPS每秒帧数，如果是红色表明帧数过低
  4. 选中一段范围，CPU中的颜色对应下方摘要的颜色范围，不同的颜色代表在某段时间CPU主要在进行何种工作（脚本、绘制、绘画、系统、空闲），如果CPU始终处于高占用，需要根据某一段时间占用CPU较多的部分进行优化
  5. 打开屏幕截图功能、悬浮于选择视图之上时可以查看在每一个时间点、网页的截图状态
  6. 在“帧”视图中可以查看具体每一段时间（按色块）的平均帧数，以及这段时间的截图
  7. 帧下面的体验会表示此段时间用户体验不好
  8. 在“更多工具”中可以打开“Rendering（绘制）”工具，在页面上添加一些渲染变化的指示框，以及展示实时的帧数表现。

## 编码工具

- VScode的使用，了解一下debugger for Chrome

## html初级

- html的基础语法是怎样构建一个.html的网页文件的

  ```html
  <!DOCTYPE html>
  <html>
      <head>
          <link rel="stylesheet" href="./css/index.css" />
          <title>网页标题</title>
      </head>
      <body>
          <div>
              www
          </div>
          <script src="./js/index.js"></script>
      </body>
  </html>
  ```

  

- 常见的内联和块级元素标签

  内联：span、strong、i、em

  块级元素：h1-h6、article、div、p、section

- 一个html中为什么CSS放前面，js放后面

  CSS放在前面可以使浏览器在加载DOM树之前先加载好CSSOM树、而js放在后面首先可以使得页面先呈现在用户面前、其次可以保证js的操作能够获取到DOM的元素。

## CSS初级

- 基本语法是怎样的

  ```
  选择器{
  	属性：属性值
  }
  ```

- CSS的工作原理

  1. HTML的加载

  　　HTML是一个网页的基础，下载完成后解析

  2. 其他静态资源加载

  　　解析HTML时，发现其中有其他外部资源链接比如CSS、JS、图片等，会立即启用别的线程下载。

  　　但当外部资源是JS时，HTML的解析会停下来，等JS下载完执行结束后才继续解析HTML，防止JS修改已经完成的解析结果

  3. DOM树构建

  　　在HTML解析的同时，解析器会把解析完成的结果转换成DOM对象，再进一步构建DOM树

  4. CSSOM树构建

  　　CSS下载完之后对CSS进行解析，解析成CSS对象，然后把CSS对象组装起来，构建CSSOM树

  5. 渲染树构建

  　　当DOM树和CSSOM树都构建完之后，浏览器根据这两个树构建一棵渲染树

  6. 布局计算

  　　渲染树构建完成以后，浏览器计算所有元素大小和绝对位置

  7. 渲染

  　　布局计算完成后，浏览器在页面渲染元素。经过渲染引擎处理后，整个页面就显示出来

  

- 原生的写法中是怎样添加一个CSS文件到html文件中的

  ```html
  <head>
      <link rel="stylesheet" href="./css/index.css" />
  </head>
  ```

- 有哪些常用的选择器

  1. 标签选择器、类选择器、id选择器
  2. 属性选择器
  3. 伪类和伪元素选择器
  4. 关系选择器

- 选择器优先级的

  **!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符和关系符 > 继承 > 浏览器默认属性**

  优先级相同，后面的规则会覆盖前面规则

- 现代浏览器的标准盒模型和IE浏览器的怪异盒模型之间的区别
  标准盒模型的宽高是直接设置到content-box之上的
  当设置`box-sizing:border-box`，宽高就设置到了border那一层，boder+padding+content的宽高才等于width或height

- 一个元素是块级还是内联元素的定义为何

  1. 内联元素只能包含内联元素，块级元素可以包含块级元素和内联元素
  2. 块级元素独占一行，内联元素可以并排

- 元素有哪些定位方式，是怎么定位的
  
- static：默认值，静态定位
  - relative：相对定位，此时设定top。。四方值可以使元素相对其静态定位的位置进行移动，但是，元素的静态定位的位置占位不会收到影响，而元素的移动也不会影响其他位置的布局。
  - absolute：绝对定位，相对于绝对定位的包含块进行定位，其包含块为它的最近的 position 的值不是 `static` （也就是值为`fixed`, `absolute`, `relative` 或 `sticky`）的祖先元素，如果其祖先都是`static`，那么相对于初始块（html也被包含在这个初始块中）定位。
  - fixed：固定定位，相对于浏览器的视口进行定位。
  
- background这个属性是如何使用的

  

## js初级

- 基础数据类型有哪些
  三值(Boolean、String、Number)两空(Null、undefined)一对象(Object)
- DOM的增删改查的方法

  1. 增

     ```js
     father.appendChild(son) // 插入到father的最后一个子节点
     document.insertBefore(relativeNode,newNode) // 将某节点插入到相对节点的前面
     // 如果appendChild和insertBefore的对象是已存在document中的内容的引用，其效果就是移动
     ```

  2. 查

     ```js
     querySelector
     querySelectorAll // NodeList静态集合
     
     getElementById
     
     getElementsByClassName// HTMLCollection，会根据DOM动态变化
     getElementsByName
     ```

  3. 改

     ```js
     innerHTML//直接修改一个元素的内部的html字符串
     innerText//直接修改一个元素的内部的文本节点字符串
     ```

  4. 删除

     ```js
     parentNode.removeChild(son) // 调用父节点的removeChild方法传入子节点的引用做删除
     node.remove() // 直接调用节点的remove做删除
     ```

- 常用的BOM如网址、端口号、path、ip、port，以及UA信息等从何处取得

  1. 网址、端口号、path、port和host都在location上
     ![image-20210815211715528](https://gitee.com/assd12138/cdnpics/raw/master/img/image-20210815211715528.png)

  2. UA信息

     从navigator.userAgent中取出![](https://gitee.com/assd12138/cdnpics/raw/master/img/20210815213854.png)
- 添加事件有哪些方法，addEventListener的几个参数是什么意思，双击的事件名是什么

  1. html行内添加事件处理程序
  2. 获取DOM元素的引用后修改其onClick的成员为事件处理函数
  3. 获取DOM元素的引用后调用`addEventListener('click',handler,isCapture)`添加事件处理函数，是否捕获默认为否
  4. IE中使用`attachEvent('onclick',handler)`添加事件处理函数
  5. 双击的事件名为`dblclick`

## 结束

> 需求分析和原型设计略
